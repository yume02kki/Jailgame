using MazeGame.MazeGame.Application.Commands;
using MazeGame.MazeGame.Application.Enums;
using MazeGame.MazeGame.Core.Enums;
using MazeGame.MazeGame.Core.Interactables;
using MazeGame.MazeGame.Core.Module;
using MazeGame.MazeGame.Presentation;

namespace MazeGame.MazeGame.Core.LoadScene;

public class MapMaker
{
    private int width;
    private int height;
    private Dictionary<IntVector2, Room> roomPositions;

    public MapMaker(int width, int height)
    {
        roomPositions = new();
        this.width = width;
        this.height = height;
    }

    public Room? tryGetRoom(IntVector2 pos)
    {
        roomPositions.TryGetValue(pos, out Room? room);
        return room;
    }

    public void addEntity(IntVector2 roomPosition, Entity entity)
    {
        Room? room = tryGetRoom(new IntVector2(roomPosition.X, roomPosition.Y));
        room?.setEntity(entity);
    }

    public Room generateRooms(string sequence)
    {
        int count = 1;
        Room spawnRoom = new Room("spawn", width, height);
        roomPositions.Add(new IntVector2(0, 0), spawnRoom);
        Room traverseRoom = spawnRoom;
        IntVector2 lastPosition = roomPositions.Last().Key;
        foreach (char letter in sequence)
        {
            Directions directions = charToDirection(letter);
            IntVector2 tempRoomPosition = lastPosition + Util.directionVector[directions];
            roomPositions.TryGetValue(tempRoomPosition, out Room? tempRoom);
            if (tempRoom == null)
            {
                tempRoom = new Room("" + count, width, height);
                roomPositions.Add(tempRoomPosition, tempRoom);
            }
            else
            {
                lastPosition = tempRoomPosition;
                traverseRoom = tempRoom;
            }

            neighborLink(traverseRoom, lastPosition, roomPositions);
            traverseRoom = tempRoom;
            lastPosition = tempRoomPosition;
            count++;
        }

        return spawnRoom;
    }

    private void neighborLink(Room room, IntVector2 position, Dictionary<IntVector2, Room> roomPositions)
    {
        foreach (Directions direction in Enum.GetValues<Directions>())
        {
            IntVector2 addedPosition = Util.directionVector[direction] + position;
            if (roomPositions.ContainsKey(addedPosition))
            {
                doorLink(room, roomPositions[addedPosition], direction);
            }
        }
    }

    private void doorLink(Room thisRoom, Room otherRoom, Directions directions)
    {
        thisRoom.linkRoom(directions, otherRoom);
        IntVector2 normalPos = getDoorPosition(directions, new IntVector2(thisRoom.playAreaWidth(), thisRoom.playAreaHeight()));
        IntVector2 mirrorPos = new IntVector2
        {
            X = Util.wrapAround(normalPos.X, otherRoom.playAreaWidth()),
            Y = Util.wrapAround(normalPos.Y, otherRoom.playAreaHeight())
        };

        Directions mirror = Util.mirrorDirection[directions];
        if (directions == Directions.RIGHT || directions == Directions.DOWN)
        {
            IntVector2 tempPos = new(normalPos);
            normalPos = mirrorPos;
            mirrorPos = tempPos;
        }

        thisRoom.setEntity(new Entity($"door {Util.enumToString(directions)}", normalPos,
            [new Open(), new Renders(new Render("☐", ConsoleColor.Green))], [Tags.Doorway]));

        otherRoom.setEntity(new Entity($"door {Util.enumToString(mirror)}", mirrorPos,
            [new Open(), new Renders(new Render("☐", ConsoleColor.Green))], [Tags.Doorway]));
    }

    public Entity getAutoGeneratedDoor(Room room, Directions? direction = null)
    {
        List<Entity> doors = room.getEntityList().FindAll(entity => entity.tags.Contains(Tags.Doorway)).Select(entity => entity).ToList();

        return direction == null ? doors.First() : doors.Find(door => door.name.Contains(Util.enumToString(direction))) ?? doors.First();
    }

    private IntVector2 getDoorPosition(Directions directions, IntVector2 pos)
    {
        double multX = 1;
        double multY = 1;
        if (directions == Directions.UP || directions == Directions.DOWN)
        {
            multX = 0.5;
            multY = 0;
        }
        else if (directions == Directions.LEFT || directions == Directions.RIGHT)
        {
            multX = 0;
            multY = 0.5;
        }

        return new IntVector2((int)Math.Ceiling(pos.X * multX), (int)Math.Ceiling(pos.Y * multY));
    }

    private Directions charToDirection(char letter)
    {
        letter = letter.ToString().ToUpper().First();
        switch (letter)
        {
            case 'L':
                return Directions.LEFT;
            case 'R':
                return Directions.RIGHT;
            case 'U':
                return Directions.UP;
            case 'D':
                return Directions.DOWN;
        }

        return default;
    }
}