using MazeGame.MazeGame.Application.Commands;
using MazeGame.MazeGame.Core.Interactables;
using MazeGame.MazeGame.Presentation;

namespace MazeGame.MazeGame.Core.Misc;

public class GameInit
{
    private int width;
    private int height;
    private Dictionary<(int x, int y), Room> roomPositions;

    public GameInit(int width, int height)
    {
        roomPositions = new();
        this.width = width;
        this.height = height;
    }

    public Room? tryGetRoom(int x, int y)
    {
        roomPositions.TryGetValue((x, y), out Room? room);
        return room;
    }

    public void addEntity((int, int) roomPosition, Entity entity)
    {
        Room? room = tryGetRoom(roomPosition.Item1, roomPosition.Item2);
        room?.setEntity(entity);
    }

    public Room generateRooms(string sequence)
    {
        int count = 1;
        Room spawnRoom = new Room("spawn", width, height);
        roomPositions.Add((0, 0), spawnRoom);
        Room traverseRoom = spawnRoom;
        (int, int) lastPosition = roomPositions.Last().Key;
        foreach (char letter in sequence)
        {
            Direction direction = charToDirection(letter);
            (int, int) tempRoomPosition = Util.addTuples(lastPosition, Util.directionToPosition(direction));
            roomPositions.TryGetValue(tempRoomPosition, out Room? tempRoom);
            if (tempRoom == null)
            {
                tempRoom = new Room("" + count, width, height);
                roomPositions.Add(tempRoomPosition, tempRoom);
            }
            else
            {
                lastPosition = tempRoomPosition;
                traverseRoom = tempRoom;
            }

            neighborLink(traverseRoom, lastPosition, roomPositions);
            traverseRoom = tempRoom;
            lastPosition = tempRoomPosition;
            count++;
        }

        return spawnRoom;
    }

    private void neighborLink(Room room, (int, int) position, Dictionary<(int x, int y), Room> roomPositions)
    {
        foreach (Direction direction in Enum.GetValues<Direction>())
        {
            (int, int) addedPosition = Util.addTuples(Util.directionToPosition(direction), position);
            if (roomPositions.ContainsKey(addedPosition))
            {
                doorLink(room, roomPositions[addedPosition], direction);
            }
        }
    }

    private void doorLink(Room thisRoom, Room otherRoom, Direction direction)
    {
        thisRoom.linkRoom(direction, otherRoom);
        int normalX, normalY;
        (normalX, normalY) = getDoorPosition(direction, thisRoom.playAreaWidth(), thisRoom.playAreaHeight());
        int mirrorX = Util.clamp(normalX, otherRoom.playAreaWidth());
        int mirrorY = Util.clamp(normalY, otherRoom.playAreaHeight());
        Direction mirror = Util.mirrorDirection(direction);
        if (direction == Direction.right || direction == Direction.down)
        {
            int tempX = normalX, tempY = normalY;
            normalX = mirrorX;
            normalY = mirrorY;
            mirrorX = tempX;
            mirrorY = tempY;
        }

        thisRoom.setEntity(new Entity($"door_{direction}", normalX, normalY, new Open(),
            new Renders(new Render("☐", ConsoleColor.Green))));
        otherRoom.setEntity(new Entity($"door_{mirror}", mirrorX, mirrorY, new Open(),
            new Renders(new Render("☐", ConsoleColor.Green))));
    }

    public Entity getAutoGeneratedDoor(Room room, Direction? direction = null)
    {
        List<Entity> doors = room.getEntityList().FindAll(entity => entity.name.Contains("door")).Select(entity => entity).ToList();
        return direction == null ? doors.First() : doors.Find(door => door.name.Contains(direction.ToString()));
    }

    private (int x, int y) getDoorPosition(Direction direction, int x, int y)
    {
        double multX = 1;
        double multY = 1;
        if (direction == Direction.up || direction == Direction.down)
        {
            multX = 0.5;
            multY = 0;
        }
        else if (direction == Direction.left || direction == Direction.right)
        {
            multX = 0;
            multY = 0.5;
        }

        return ((int)Math.Ceiling(x * multX), (int)Math.Ceiling(y * multY));
    }

    private Direction charToDirection(char letter)
    {
        letter = letter.ToString().ToUpper()[0];
        switch (letter)
        {
            case 'L':
                return Direction.left;
            case 'R':
                return Direction.right;
            case 'U':
                return Direction.up;
            case 'D':
                return Direction.down;
        }

        return default;
    }
}