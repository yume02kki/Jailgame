using MazeGame.MazeGame.Application.Commands;
using MazeGame.MazeGame.Core;
using MazeGame.MazeGame.Core.Enforcers;
using MazeGame.MazeGame.Core.Interactables;
using MazeGame.MazeGame.Core.Misc;
using MazeGame.MazeGame.Presentation;

namespace MazeGame.MazeGame.Application;

public class GameCreator
{
    private const int SIZE_W = 6;
    private const int SIZE_H = 4;
    private const string SEQUENCE = "LUURULUDL";

    //singleton
    private static readonly Lazy<GameCreator> _instance = new Lazy<GameCreator>(() => new GameCreator());
    public static GameCreator Instance => _instance.Value;
    public GameStatus gameStatus = GameStatus.ongoing;
    public Player player;

    private GameCreator()
    {
        GameProfile profile = new GameProfile(SIZE_W, SIZE_H, SEQUENCE);
        GameInit init = profile.init;
        player = profile.player;
        Dictionary<string, Room> rooms = profile.rooms;

        //Needle
        GameObject needle = new GameObject("needle");

        //Dog Food
        GameObject dogFood = new GameObject("bonzo");

        //Door
        {
            //TODO: add tag system
            Entity firstDoor = init.getAutoGeneratedDoor(rooms["spawn"]);
            LockEnforcer lockEnforcer = new LockEnforcer();
            Open lockedDoor = new Open(lockEnforcer: lockEnforcer);
            Used used = new Used(needle, lockEnforcer.unlock);
            Collide collide = new Collide(() => !lockedDoor.isOpen);
            Render closed = new Render("▥", ConsoleColor.Red);
            Render open = new Render("☐", ConsoleColor.Green);
            Renders render = new Renders(() => lockedDoor.isOpen, open, closed);
            init.addEntity((0, 0),
                new Entity(firstDoor.name, firstDoor.x, firstDoor.y, lockedDoor, used, render, collide));
        }

        //Bed
        {
            Renders render = new Renders(new Render("_", ConsoleColor.Blue));
            Examine examine = new Examine(needle, player.addToInventory);
            init.addEntity((0, 0), new Entity("bed", 2, 1, render, examine));
        }

        //Dog
        {
            bool dogHungry = true;
            Entity dogDoor = init.getAutoGeneratedDoor(rooms["dog"], Direction.up);
            Render hungry = new Render("☗", ConsoleColor.Yellow);
            Render fed = new Render("☖", ConsoleColor.Yellow);
            Used used = new Used(dogFood, () => dogHungry = false);
            Collide collide = new Collide(() => dogHungry);
            Renders renders = new Renders(() => dogHungry, hungry, fed);
            init.addEntity((-1, 3), new Entity("dog", dogDoor.x, dogDoor.y + 1, renders, collide, used));
        }

        //Bowl
        {
            Renders render = new Renders(new Render("◡", ConsoleColor.Yellow));
            Examine examine = new Examine(dogFood, player.addToInventory);
            init.addEntity((0, 3), new Entity("bowl", 4, 1, render, examine));
        }

        //Guard
        {
            Renders render = new Renders(new Render("¶", ConsoleColor.Blue));
            OnLoad kill = new OnLoad(() => gameStatus = GameStatus.lose);
            init.addEntity((-2, 3), new Entity("guard", 2, 2, render, kill));
        }

        //Escape
        {
            Renders render = new Renders(new Render("♕", ConsoleColor.Yellow));
            OnLoad win = new OnLoad(() => gameStatus = GameStatus.win);
            init.addEntity((-1, 4), new Entity("win", 2, 2, render, win));
        }
    }
}